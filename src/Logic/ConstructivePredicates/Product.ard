\import Function
\import Function.Meta
\import Logic
\import Logic.ConstructivePredicates.Signature
\import Logic.ConstructivePredicates.Structure
\import Logic.Meta
\import Order.Filter
\import Paths
\import Paths.Meta
\import Relation.Equivalence
\import Set.SubsetLattice

\record Product {S : Signature} {I : \Type} (A : I -> Structure S) (\coerce a : \Pi (i : I) -> A i)

\instance ProductStructure {S : Signature} {I : \Type} (A : I -> Structure S) : Structure S (Product A)
  | ! f a => \new Product _ (\lam i => f ! (\lam j => a j i))
  | ? p a => ∀ (i : I) (p ? (\lam j => a j i))

\func IFilter (I : \Type) : \Type => Filter (SubsetLattice I)

\instance FilterEquivalence {S : Signature} {I : \Type} (A : I -> Structure S) (F : IFilter I)
: Equivalence (Product A)
  | ~ a b => F (\lam i => a i = b i)
  | ~-reflexive => transport F (ext (\lam i => propExt (\lam _ => idp) (\lam _ => absurd))) filter-top
  | ~-symmetric => transport F (ext (\lam i => propExt inv inv))
  | ~-transitive {a} {b} {c} aFb bFc =>
    filter-up (\lam {i} (p : \Sigma (a i = b i) (b i = c i)) => p.1 *> p.2) (filter-meet aFb bFc)

\func FilteredProduct {I : \Type} (F : IFilter I) {S : Signature} (A : I -> Structure S) =>
  Quotient (~ {FilterEquivalence A F})
  \where {
    \func isStableFun {B : \Type} (R : B -> B -> \Prop) {n : Nat} (f : Array (Product A) n -> B) : \Prop =>
      ∀ {l l' : Array (Product A) n} ((∀ (i : Fin n) (l i ~ {FilterEquivalence _ F} l' i)) -> f l `R` f l')

    \func liftArrayFun {B : \Type} (R : B -> B -> \Prop) {n : Nat}
                       (f : Array (Product A) n -> B) (s : isStableFun R f)
      : Array (FilteredProduct F A) n -> Quotient R =>
      Quotient.liftArrayFun (__ ~ __) (\lam _ => ~-reflexive) R f (\lam _ _ => s)

    \func liftArrayEndo {n : Nat} (f : Array (Product A) n -> Product A)
                        (s : isStableFun (~ {FilterEquivalence _ F}) f)
      : Array (FilteredProduct F A) n -> FilteredProduct F A => liftArrayFun _ _ s

    \func isStableProp {n : Nat} (f : Array (Product A) n -> \Prop) : \Prop =>
      ∀ {l l' : Array (Product A) n} ((∀ (i : Fin n) (l i ~ {FilterEquivalence _ F} l' i)) -> f l -> f l')

    \func liftArrayPred {n : Nat} (f : Array (Product A) n -> \Prop) (s : isStableProp f)
      : Array (FilteredProduct F A) n -> \Prop =>
      fromEq o liftArrayFun _ f (\lam p => propExt (s p) (s (\lam i => ~-symmetric (p i))))

    \func fromEq {A : \Set} (q : Quotient {A} (=)) : A \elim q
      | in~ a => a
      | ~-equiv _ _ r => r
  }

\instance FilteredStructure {S : Signature} {I : \Type} (A : I -> Structure S) (F : IFilter I)
: Structure S (FilteredProduct F A)
  | ! f => FilteredProduct.liftArrayEndo F A (f !) $
  \lam {l} {l'} p =>
      filter-up (\lam q => pmap (f !) (exts (fin-meet-index q)))
          (F.filter-fin-meet (\lam j i => l j i = l' j i) p)
  | ? p => FilteredProduct.liftArrayPred F A (\lam a => F (\lam i => p ? (\lam j => a j i))) $
  \lam {l} {l'} q f =>
      F.filter-up-flip
          (filter-meet f (F.filter-fin-meet (\lam j i => l j i = l' j i) q))
          {\lam i => p ? (\lam j => l' j i)}
          (\lam (l?, l~l') => transport (p ?) (exts (fin-meet-index l~l')) l?)